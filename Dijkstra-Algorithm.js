graph = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
]

//Finds Children of a given node
function Children(graph, x, y) {
	let ChildList = [];
	let left = graph[x][y - 1];
	let topLeft = undefined;
	let top = undefined;
	let topRight = undefined;
	let right = graph[x][y + 1];
	let bottomRight = undefined;
	let bottom = undefined;
	let bottomLeft = undefined;
	if (x > 0) {
		topLeft = graph[x - 1][y - 1];
		top = graph[x - 1][y];
		topRight = graph[x - 1][y + 1];
	}
	if (x < graph.length - 1) {
		bottomRight = graph[x + 1][y + 1];
		bottom = graph[x + 1][y];
		bottomLeft = graph[x + 1][y - 1];
	}
	let adjList = [
		left,
		topLeft,
		top,
		topRight,
		right,
		bottomRight,
		bottom,
		bottomLeft,
	];

	let childPosLi = [
		[x, y - 1],
		[x - 1, y - 1],
		[x - 1, y],
		[x - 1, y + 1],
		[x, y + 1],
		[x + 1, y + 1],
		[x + 1, y],
		[x + 1, y - 1],
	];
	for (let i = 0; i <= 8; i++) {
		if (adjList[i] == undefined) {
			continue;
		} else {
			let x = childPosLi[i][0];
			let y = childPosLi[i][1];
			ChildList.push([x, y]);
		}
	}
	return ChildList;
}

//Finds the index of the node with the lowest score
function findLowestIndex(graphScore, graphVisited) {
	let LowScore = Infinity;
	for (let row = 0; row < graphScore.length; row++) {
		for (let col = 0; col < graphScore[0].length; col++) {
			if (
				graphScore[row][col] < LowScore &&
				graphVisited[row][col] == false
			) {
				LowScore = graphScore[row][col];
				LowestIndex = [row, col];
				continue;
			} else {
				continue;
			}
		}
	}
	if (LowScore == Infinity) {
		return false;
	}
	return LowestIndex;
}

//Processes the starting node
function processStartNode(graph, graphScore, graphPath, graphVisited, x, y) {
	graphScore[x][y] = 0;
	graphPath[x][y] = null;
	graphVisited[x][y] = true;
	let childNodes = Children(graph, x, y);
	for (start = 0; start <= childNodes.length - 1; start++) {
		let a = childNodes[start][0];
		let b = childNodes[start][1];
		graphScore[a][b] = graphScore[x][y] + 1;
		graphPath[a][b] = [x, y];
	}
}

//Finds the node with the lowest score and processes it, if processed node is End node return true
function processNodes(graph, graphScore, graphPath, graphVisited) {
	let NodeProcessPosition = findLowestIndex(graphScore, graphVisited);
	let a = NodeProcessPosition[0];
	let b = NodeProcessPosition[1];
	let childNodes = Children(graph, a, b);
	graphVisited[a][b] = true;
	for (let i = 0; i < childNodes.length; i++) {
		let childRow = childNodes[i][0];
		let childCol = childNodes[i][1];
		if (a == childRow || b == childCol) {
			if (graphScore[childRow][childCol] > graphScore[a][b] + 1) {
				graphScore[childRow][childCol] = graphScore[a][b] + 1;
				graphPath[childRow][childCol] = [a, b];
			}
		} else if (a !== childRow && b !== childCol) {
			if (graphScore[childRow][childCol] > graphScore[a][b] + 1.1) {
				graphScore[childRow][childCol] = graphScore[a][b] + 1.1;
				graphPath[childRow][childCol] = [a, b];
			}
		}
	}
	if (graph[a][b] == 'E') {
		return true;
	}
}

//maps the shortest path from start node to end node
function mapPath(graphPath, x, y) {
	let finishedPath = false;
	let travelPath = graphPath[x][y];
	let Path = [[x, y]];
	while (finishedPath == false) {
		Path.push(travelPath);
		travelPath = graphPath[travelPath[0]][travelPath[1]];
		if (travelPath == null) {
			finishedPath = true;
		}
	}
	return Path.reverse();
}

//ab = starting positon in list form, cd end position in list form
function dijkstra(graph, ab, cd) {
	let graphScore = graph
		.map(x => x.slice())
		.map(x => x.map(x => (x = Infinity)));
	let graphPath = graph
		.map(x => x.slice())
		.map(x => x.map(x => (x = 'noPath')));
	let graphVisited = graph
		.map(x => x.slice())
		.map(x => x.map(x => (x = false)));
	let pathFound = false;
	graph[ab[0]][ab[1]] = 'S';
	graph[cd[0]][cd[1]] = 'E';
	processStartNode(graph, graphScore, graphPath, graphVisited, ab[0], ab[1]);
	while (pathFound == false) {
		let proNode = processNodes(graph, graphScore, graphPath, graphVisited);
		if (proNode == true) {
			pathFound = true;
			return mapPath(graphPath, cd[0], cd[1]);
		}
	}
}

console.log(dijkstra(graph, [0, 0], [20, 20]));
