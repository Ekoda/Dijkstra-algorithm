// prettier-ignore
graph = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
]

//Finds Children of a given node
function Children(graph, x, y) {
	ChildList = [];
	left = graph[x][y - 1];
	topLeft = undefined;
	top = undefined;
	topRight = undefined;
	right = graph[x][y + 1];
	bottomRight = undefined;
	bottom = undefined;
	bottomLeft = undefined;
	if (x > 0) {
		topLeft = graph[x - 1][y - 1];
		top = graph[x - 1][y];
		topRight = graph[x - 1][y + 1];
	}
	if (x < graph.length - 1) {
		bottomRight = graph[x + 1][y + 1];
		bottom = graph[x + 1][y];
		bottomLeft = graph[x + 1][y - 1];
	}
	adjList = [
		left,
		topLeft,
		top,
		topRight,
		right,
		bottomRight,
		bottom,
		bottomLeft,
	];

	childPosLi = [
		[x, y - 1],
		[x - 1, y - 1],
		[x - 1, y],
		[x - 1, y + 1],
		[x, y + 1],
		[x + 1, y + 1],
		[x + 1, y],
		[x + 1, y - 1],
	];
	for (counter = 0; counter <= 8; counter++) {
		if (adjList[counter] == undefined) {
			continue;
		} else {
			CpX = childPosLi[counter][0];
			CpY = childPosLi[counter][1];
			ChildList.push([CpX, CpY]);
		}
	}
	return ChildList;
}

//Finds the index of the node with the lowest score
function findLowestIndex(graphScore, graphVisited) {
	LowScore = Infinity;
	lowestIndex = [];
	for (lowR = 0; lowR < graphScore.length; lowR++) {
		for (lowC = 0; lowC < graphScore[0].length; lowC++) {
			if (
				graphScore[lowR][lowC] < LowScore &&
				graphVisited[lowR][lowC] == false
			) {
				LowScore = graphScore[lowR][lowC];
				LowestIndex = [lowR, lowC];
				continue;
			} else {
				continue;
			}
		}
	}
	if (LowScore == Infinity) {
		return false;
	}
	return LowestIndex;
}

//Processes the starting node
function processStartNode(graph, graphScore, graphPath, graphVisited, x, y) {
	graphScore[x][y] = 0;
	graphPath[x][y] = null;
	graphVisited[x][y] = true;
	childNodes = Children(graph, x, y);
	for (start = 0; start <= childNodes.length - 1; start++) {
		cR = childNodes[start][0];
		cC = childNodes[start][1];
		graphScore[cR][cC] = graphScore[x][y] + 1;
		graphPath[cR][cC] = [x, y];
	}
}

//Finds the node with the lowest score and processes it, if processed node is End node return true
function processNodes(graph, graphScore, graphPath, graphVisited) {
	NodeProcessPosition = findLowestIndex(graphScore, graphVisited);
	a = NodeProcessPosition[0];
	b = NodeProcessPosition[1];
	childNodes = Children(graph, a, b);
	graphVisited[a][b] = true;
	for (i = 0; i < childNodes.length; i++) {
		childNodeRow = childNodes[i][0];
		childNodeCol = childNodes[i][1];
		if (a == childNodeRow || b == childNodeCol) {
			if (graphScore[childNodeRow][childNodeCol] > graphScore[a][b] + 1) {
				graphScore[childNodeRow][childNodeCol] = graphScore[a][b] + 1;
				graphPath[childNodeRow][childNodeCol] = [a, b];
			}
		} else if (a !== childNodeRow && b !== childNodeCol) {
			if (
				graphScore[childNodeRow][childNodeCol] >
				graphScore[a][b] + 1.1
			) {
				graphScore[childNodeRow][childNodeCol] = graphScore[a][b] + 1.1;
				graphPath[childNodeRow][childNodeCol] = [a, b];
			}
		}
	}
	if (graph[a][b] == 'E') {
		return true;
	}
}

//maps the shortest path from start node to end node
function mapPath(graphPath, x, y) {
	finishedPath = false;
	travelPath = graphPath[x][y];
	Path = [[x, y]];
	while (finishedPath == false) {
		Path.push(travelPath);
		travelPath = graphPath[travelPath[0]][travelPath[1]];
		if (travelPath == null) {
			finishedPath = true;
		}
	}
	return Path.reverse();
}

//ab = starting positon in list form, cd end position in list form
function dijkstra(graph, ab, cd) {
	graphScore = graph.map(x => x.slice()).map(x => x.map(x => (x = Infinity)));
	graphPath = graph.map(x => x.slice()).map(x => x.map(x => (x = 'noPath')));
	graphVisited = graph.map(x => x.slice()).map(x => x.map(x => (x = false)));
	pathFound = false;
	graph[ab[0]][ab[1]] = 'S';
	graph[cd[0]][cd[1]] = 'E';
	processStartNode(graph, graphScore, graphPath, graphVisited, ab[0], ab[1]);
	while (pathFound == false) {
		proNode = processNodes(graph, graphScore, graphPath, graphVisited);
		if (proNode == true) {
			pathFound = true;
			return mapPath(graphPath, cd[0], cd[1]);
		}
	}
}

console.log(dijkstra(graph, [0, 0], [15, 15]));
